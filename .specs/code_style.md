# EventBus Platform 程式碼風格與開發原則

基於 [api.template](./examples/api.template) 範例專案制定的開發標準與最佳實務。

## 架構原則

### Clean Architecture 分層設計
專案採用 Clean Architecture 模式，明確分離各層職責：

- **WebAPI 層**: 控制器 (Controller) 與 API 介面
- **Handler 層**: 業務邏輯處理器
- **Repository 層**: 資料存取層
- **Infrastructure 層**: 跨領域服務 (快取、追蹤、工具)
- **Contract 層**: API 客戶端合約 (自動產生)
- **DB 層**: Entity Framework Core 實體 (自動產生)

### 核心設計模式
1. **Result Pattern**: 使用 `Result<TSuccess, TFailure>` 處理成功/失敗回傳
2. **Repository Pattern**: 透過 Repository 進行資料存取
3. **Handler Pattern**: 業務邏輯封裝在 Handler 中
4. **Middleware Pipeline**: 使用中介軟體處理跨領域關注點
5. **依賴注入**: 完整的 DI 容器配置

## 程式碼組織結構

### 專案命名慣例
```
{ProjectName}.{Domain}.{Layer}
例如：EventBus.Platform.WebAPI
      EventBus.Platform.Infrastructure
      EventBus.Platform.DB
```

### 檔案組織
```
src/
└── be/
    ├── {ProjectName}.Infrastructure/       # 基礎設施層
    │   ├── Caching/                       # 快取相關
    │   ├── TraceContext/                  # 追蹤內容
    │   └── Extensions/                    # 擴充方法
    ├── {ProjectName}.{Domain}.WebAPI/     # Web API 層
    │   ├── Controllers/                   # 控制器
    │   ├── Handlers/                      # 業務處理器
    │   ├── Repositories/                  # 資料存取
    │   ├── Contract/AutoGenerated/        # 自動產生的 API 合約
    │   └── Models/                        # 資料模型
    ├── {ProjectName}.{Domain}.DB/         # 資料庫層
    │   └── AutoGenerated/                 # EF Core 自動產生實體
    ├── {ProjectName}.{Domain}.Contract/   # API 客戶端合約
    └── {ProjectName}.Testing.Common/      # 共用測試工具
```

## 程式碼風格標準

### C# 程式碼慣例

#### 命名規則
- **類別**: `PascalCase` (例: `MemberHandler`, `TraceContext`)
- **方法**: `PascalCase` (例: `CreateAsync`, `GetByIdAsync`) 
- **屬性**: `PascalCase` (例: `TraceId`, `UserId`)
- **欄位**: `camelCase` 且使用 `_` 前綴 (例: `_logger`, `_repository`)
- **參數**: `camelCase` (例: `request`, `cancellationToken`)
- **區域變數**: `camelCase` (例: `result`, `entity`)

#### 非同步方法
- 所有非同步方法必須以 `Async` 結尾
- 必須接受 `CancellationToken` 參數
- 使用 `ConfigureAwait(false)` (除了 UI 應用程式)

```csharp
public async Task<Result<Member, Failure>> CreateAsync(
    CreateMemberRequest request, 
    CancellationToken cancellationToken = default)
{
    var result = await _repository.CreateAsync(request, cancellationToken)
        .ConfigureAwait(false);
    return result;
}
```

#### Record Types 與不可變物件
- 使用 `record` 定義不可變的資料物件
- 屬性使用 `init` 關鍵字

```csharp
public record TraceContext
{
    public string TraceId { get; init; }
    public string UserId { get; init; }
}
```

### 建構子注入模式
使用 Primary Constructor 語法簡化依賴注入：

```csharp
public class MemberHandler(
    MemberRepository repository,
    IContextGetter<TraceContext?> traceContextGetter,
    ILogger<MemberHandler> logger)
{
    // 方法實作...
}
```

### Result Pattern 實作標準

#### 成功回傳
```csharp
return Result.Success<Member, Failure>(entity);
```

#### 失敗回傳
```csharp
return Result.Failure<Member, Failure>(new Failure
{
    Code = nameof(FailureCode.ValidationError),
    Message = "驗證失敗訊息",
    TraceId = traceContext?.TraceId,
    Exception = ex // 僅在內部使用，不會序列化給客戶端
});
```

#### 結果檢查與轉換
```csharp
// Handler 層
var result = await repository.CreateAsync(request, cancellationToken);
if (result.IsFailure)
{
    return Result.Failure<Member, Failure>(result.Error);
}

// Controller 層
var result = await handler.CreateAsync(request, cancellationToken);
return result.ToApiResult(); // 擴充方法統一轉換
```

## 錯誤處理策略

### FailureCode 列舉
```csharp
public enum FailureCode
{
    Unauthorized,        // 401 - 未授權
    ValidationError,     // 400 - 驗證錯誤  
    NotFound,           // 404 - 找不到資源
    DuplicateEmail,     // 409 - 重複資料
    DbError,            // 500 - 資料庫錯誤
    DbConcurrency,      // 409 - 併發衝突
    Timeout,            // 408 - 逾時
    InternalServerError, // 500 - 內部錯誤
    Unknown             // 500 - 未知錯誤
}
```

### 分層錯誤處理
1. **Business Logic Error**: 在 Handler/Repository 層使用 Result Pattern
2. **System Exception**: 在 ExceptionHandlingMiddleware 統一處理
3. **絕不重複拋出例外**: 處理過的例外不再 throw

## 追蹤與日誌標準

### TraceContext 管理
- 在 `TraceContextMiddleware` 統一處理身分驗證與追蹤內容
- 透過 `IContextGetter<TraceContext?>` 取得追蹤資訊
- 所有日誌與錯誤回應都包含 `TraceId`

### 日誌記錄原則
- **結構化日誌**: 使用 Serilog 與結構化格式
- **集中記錄**: 在 Middleware 層統一記錄，避免在 Handler 重複
- **安全性**: 過濾敏感標頭 (Authorization, Cookie 等)
- **TraceId 整合**: 自動附加追蹤資訊到所有日誌

```csharp
logger.LogInformation(
    "成功建立實體: {EntityId} - TraceId: {TraceId}", 
    entity.Id, traceContext?.TraceId);
```

## 資料存取模式

### Entity Framework Core 最佳實務
- **查詢優化**: 使用 `AsNoTracking()` 進行唯讀查詢
- **併發處理**: 妥善處理 `DbUpdateConcurrencyException`
- **異動追蹤**: 僅在需要時啟用 Change Tracking

### 快取策略
- 使用 `ICacheProvider` 抽象化快取實作
- Redis 主要，Memory Cache 備援
- 快取鍵命名: `{EntityType}_{Id}` 格式
- 適當的快取過期時間設定

```csharp
private const string CacheKeyPrefix = "Member_";
private readonly TimeSpan CacheDuration = TimeSpan.FromMinutes(30);
```

### 分頁實作
- **Offset Pagination**: 使用 `PaginatedList<T>` 
- **Cursor Pagination**: 使用 `CursorPaginatedList<T>`
- 分頁參數透過 HTTP Header 傳遞：`x-page-size`, `x-page-index`, `x-next-page-token`

## API 設計標準

### Controller 實作模式
- 實作自動產生的 Interface (`I{Entity}Controller`)
- 使用 `{Entity}ControllerImpl` 命名慣例
- HTTP Header 參數擷取邏輯封裝在私有方法

### HTTP 回應標準
```csharp
// 成功建立資源
return CreatedAtAction(
    nameof(GetMemberByIdAsync), 
    new { id = result.Value.Id }, 
    response);

// 成功更新
return Ok(response);

// 成功刪除
return NoContent();

// 業務邏輯錯誤
return result.ToFailureResult();
```

### API 合約自動產生
- OpenAPI-first 開發流程
- API 規格維護在 `doc/openapi.yml`
- 使用 NSwag 產生伺服器端控制器
- 使用 Refitter 產生客戶端程式碼

## 測試策略

### 測試分類
- **Unit Tests**: 使用 xUnit + FluentAssertions
- **Integration Tests**: 使用 Testcontainers + 真實資料庫
- **BDD Tests**: 使用 Reqnroll (SpecFlow 繼任者)

### 測試專案結構
```
{ProjectName}.{Domain}.Test/              # 單元測試
{ProjectName}.{Domain}.IntegrationTest/   # 整合測試  
{ProjectName}.Testing.Common/             # 共用測試工具
```

## 開發工作流程

### Task Runner 使用
專案使用 Taskfile.yml 管理開發任務：

```bash
# 開發環境初始化
task dev-init

# 啟動開發模式 API
task api-dev

# 程式碼產生
task codegen-api          # 產生 API 客戶端與伺服器端
task ef-codegen          # 產生 EF Core 實體

# 基礎設施
task redis-start         # 啟動 Redis
task redis-admin-start   # 啟動 Redis 管理介面
```

### 程式碼產生流程
1. 更新 `doc/openapi.yml` API 規格
2. 執行 `task codegen-api` 重新產生程式碼
3. 實作 Handler 與 Repository 業務邏輯
4. 執行測試驗證功能

### 環境配置
- 開發環境使用 `env/local.env` 環境變數
- 使用 `--local` 參數載入本地設定
- 支援 Docker Compose 整合開發環境

## 安全性要求

### 輸入驗證
- 使用 Data Annotations 進行模型驗證
- 自訂驗證屬性防範腳本注入
- 適當的字串長度與格式限制

### 回應安全
- 生產環境不洩露詳細錯誤訊息
- 過濾敏感 HTTP 標頭
- 使用適當的 HTTP 狀態碼

### 快取安全
- 敏感資料不進入快取
- 適當的快取過期策略
- 資料異動時主動清除快取

## 效能考量

### 非同步程式設計
- 全面使用 async/await 模式
- 避免 `.Result` 與 `.Wait()` 造成死鎖
- 使用 `ConfigureAwait(false)` 優化效能

### 資料庫優化  
- 適當的查詢索引設計
- 使用 `AsNoTracking()` 優化查詢
- 批量操作使用 EF Core Extensions

### 記憶體管理
- 使用 `using` 或 `using var` 管理資源
- 避免頻繁的大物件配置
- 適當使用物件池 (Object Pool)

## 部署與維運

### 容器化
- 使用多階段 Dockerfile 建置
- 設定健康檢查端點
- 環境變數外部化設定

### 監控
- 整合 Application Insights 或類似 APM 工具
- 結構化日誌輸出到 Seq 或 ELK Stack  
- OpenTelemetry 分散式追蹤

### 健康檢查
- `/health` - 完整健康檢查
- `/health/ready` - 就緒性檢查 (資料庫、快取)
- `/health/live` - 存活性檢查 (API 本身)

---

## 程式碼範本參考

範本檔案位於 `.claude/templates/`:
- `controller-template.cs` - 控制器實作範本
- `handler-template.cs` - 業務處理器範本  
- `repository-template.cs` - 資料存取範本
- `model-template.cs` - 資料模型範本
- `middleware-template.cs` - 中介軟體範本

這些範本提供了符合專案標準的程式碼結構，可用於快速建立新功能。

## 持續改進

此文檔將隨專案演進持續更新，確保開發團隊遵循一致的程式碼品質與架構標準。如有建議或改進，請透過專案 Issue 或 Pull Request 提出討論。